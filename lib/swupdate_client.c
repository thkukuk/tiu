/*  Copyright (C) 2022  Thorsten Kukuk <kukuk@suse.com>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; If not, see <http://www.gnu.org/licenses/>.
*/

#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>

#include <glib/gprintf.h>

/* swupdate */
#include <network_ipc.h>

/* tiu internal */
#include "tiu.h"
#include "tiu-internal.h"
#include "tiu-swupdate.h"

static int fd = -1;
static pthread_mutex_t mymutex;
static pthread_cond_t cv_end = PTHREAD_COND_INITIALIZER;
static gboolean retval = FALSE;
static char buf[256];

/*
 * this is the callback to get a new chunk of the
 * image.
 * It is called by a thread generated by the library and
 * can block.
 */
static int
readimage (char **p, int *size)
{
  int ret;

  ret = read(fd, buf, sizeof(buf));
  *p = buf;
  *size = ret;

  return ret;
}

/*
 * This is called by the library to inform
 * about the current status of the upgrade
 */
static int
printstatus (ipc_message *msg)
{
  if (verbose_flag)
    g_printf ("Status: %d message: %s\n",
	      msg->data.status.current,
	      strlen(msg->data.status.desc) > 0 ? msg->data.status.desc : "");
  return 0;
}

/*
 * this is called at the end reporting the status
 * of the upgrade and running any post-update actions
 * if successful
 */
static int
end (RECOVERY_STATUS status)
{
  retval = (status == SUCCESS) ? TRUE : FALSE;

  pthread_mutex_lock(&mymutex);
  pthread_cond_signal(&cv_end);
  pthread_mutex_unlock(&mymutex);

  return 0;
}

/* Tell swupdate to deploy the image */
gboolean
swupdate_deploy (const char* archive, GError **error)
{
  if (archive == NULL) {
    /* XXX set error */
    return FALSE;
  }

  if ((fd = open(archive, O_RDONLY)) < 0)
    {
      g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(errno),
                  "Unable to open '%s'", archive);
      return FALSE;
    }

  pthread_mutex_init(&mymutex, NULL);

  struct swupdate_request req;
  swupdate_prepare_req(&req);

  int ret = swupdate_async_start(readimage, printstatus, end, &req, sizeof(req));
  /* return if we've hit an error scenario */
  if (ret < 0)
    {
      g_set_error(error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                  "swupdate_async_start returned '%d'", ret);
      close(fd);
      return FALSE;
    }

  /* End called, unlock and exit */
  pthread_mutex_lock(&mymutex);
  pthread_cond_wait(&cv_end, &mymutex);
  pthread_mutex_unlock(&mymutex);

  if (fd >= 0)
    close(fd);

  if (retval != TRUE)
    {
      /* Find a way to get the real error... */
      g_set_error(error, G_FILE_ERROR, G_FILE_ERROR_FAILED,
                  "Updating /usr with swupdate failed!");
    }

  if (verbose_flag)
    g_printf("Updating /usr with swupdate %s\n",
	     retval == FALSE ? "failed!" : "was successful!");

  return retval;
}
